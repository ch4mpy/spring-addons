# How to configure a Spring REST API with an additional security filter-chain for UI resources

## 1. Overview
The aim here is to demo OAuth2 configuration when a Spring backend is both a client and a resource-server.

It is important to note that in this configuration, the end-user browser **is not an OAuth2 client**. It is secured with regular sessions, which must be enabled on the SecurityFilterChain dedicated to UI resources. The OAuth2 client is the server-side part of the Spring application which renders UI elements.

Be sure your environment meets [tutorials prerequisits](https://github.com/ch4mpy/spring-addons/blob/master/samples/tutorials/README.md#prerequisites).

## 2. Scenario Details
We will implement a Spring backend with
- a resource-server (REST API)
  * session-less (with CSRF disabled)
  * returning 401 (unauthorized) if a request is unauthorized
  * serving greeting messaged customized with authenticated user name
- a Thymeleaf client for the above resource-server
  * sessions are required as requests from browsers won't be authorized (no authorization header with Bearer token) => CSRF protection must be activated
  * returning the default 302 (redirect to login) if the user has no session yet
  * an index page, loaded after authentication, with links to Thymeleaf page and Swager-UI index
- spring-boot-actuator with some public REST endpoints (liveness & readiness) and others requiring requests to be authorized
- Swagger-UI with
  * `/v3/api-docs/**` JSON resources publicly accessible
  * `/swagger-ui/**` HTML pages accessible to users with active session
  

## 3. Project Initialisation
We'll start a spring-boot 3 project with the help of https://start.spring.io/
Following dependencies will be needed:
- lombok
- spring-boot-starter-web (used by both REST API and UI servlets)
- spring-boot-starter-webflux (required for WebClient)
- spring-boot-starter-oauth2-client
- spring-boot-starter-thymeleaf
- spring-boot-starter-actuator

Then add this dependencies to spring-addons:
```xml
		<dependency>
			<groupId>com.c4-soft.springaddons</groupId>
			<artifactId>spring-addons-webmvc-jwt-resource-server</artifactId>
			<version>6.0.8</version>
		</dependency>
		<dependency>
			<groupId>org.springdoc</groupId>
			<artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>
			<version>2.0.0</version>
		</dependency>
		<dependency>
			<groupId>com.c4-soft.springaddons</groupId>
			<artifactId>spring-addons-webmvc-jwt-test</artifactId>
			<version>6.0.8</version>
			<scope>test</scope>
		</dependency>
```

## 4. Web-Security Configuration

This tutorial is using `spring-addons-webmvc-jwt-resource-server`, which auto-configures a default SecurityFilterChain for resource-server (REST API), based on properties file. **This resource-server security filter-chain is not explicitly defined in security-conf, but it it there!** Refer to `resource-server_with_jwtauthenticationtoken` tutorial for instructions to define such a security filter-chain by yourself (without the help of `spring-addons-webmvc-jwt-resource-server`).

We will add another `SecurityFilterChain` which should apply selectively to all UI elements: those required for 
- Thymeleaf pages
- OAuth2 login and callback endpoints generated by spring-boot
- Swagger-UI.

Last, we'll provide some bridge configuration for WebClient which, by default, expects reactive configuration.
```java
@Configuration
@EnableMethodSecurity
public class WebSecurityConfig {
	/**
	 * By default, WebClient expects reactive OAuth2 configuration. This bridges from ClientRegistrationRepository to ReactiveClientRegistrationRepository
	 * @param clientRegistrationRepository
	 * @param authorizedClientService
	 * @return
	 */
	@Bean
	WebClient webClient(ClientRegistrationRepository clientRegistrationRepository,
			OAuth2AuthorizedClientService authorizedClientService) {
		var oauth = new ServletOAuth2AuthorizedClientExchangeFilterFunction(
				new AuthorizedClientServiceOAuth2AuthorizedClientManager(clientRegistrationRepository,
						authorizedClientService));
		oauth.setDefaultClientRegistrationId("spring-addons-public");
		return WebClient.builder().apply(oauth.oauth2Configuration()).build();
	}

	/**
	 * <p>
	 * A default SecurityFilterChain is already defined by
	 * spring-addons-webmvc-jwt-resource-server to secure all API endpoints
	 * (actuator and REST controllers)
	 * </p>
	 * We define here another SecurityFilterChain for server-side rendered pages:
	 * <ul>
	 * <li>oauth2Login generated page and callback endpoint</li>
	 * <li>Swagger UI</ui>
	 * <li>Thymeleaf pages served by UiController</li>
	 * </ul>
	 * <p>
	 * It important to note that in this scenario, the end-user browser is not an
	 * OAuth2 client. Only the part of the server-side part of the Spring
	 * application secured with this filter chain is. Requests between the browser
	 * and Spring OAuth2 client are secured with <b>sessions</b>. As so, <b>CSRF
	 * protection must be active</b>.
	 * </p>
	 *
	 * @param http
	 * @param serverProperties
	 * @return an additional security filter-chain for UI elements (with OAuth2
	 *         login)
	 * @throws Exception
	 */
	@Order(Ordered.HIGHEST_PRECEDENCE)
	@Bean
	SecurityFilterChain uiFilterChain(HttpSecurity http, ServerProperties serverProperties,
			Converter<Map<String, Object>, Collection<? extends GrantedAuthority>> authoritiesConverter)
			throws Exception {
		boolean isSsl = serverProperties.getSsl() != null && serverProperties.getSsl().isEnabled();

		// @formatter:off
	    http.securityMatcher(new OrRequestMatcher(
	            // UiController pages
	            new AntPathRequestMatcher("/ui/**"),
	            // Swagger pages
	            new AntPathRequestMatcher("/swagger-ui/**"),
	            // those two are required to access Spring generated login page
	            // and OAuth2 client callback endpoints
	            new AntPathRequestMatcher("/login/**"),
	            new AntPathRequestMatcher("/oauth2/**")));
	
	    http.oauth2Login()
	    		// I don't know quite why we are redirected to authorization-server port by default as initial login page is generated on client :/
			    .loginPage("%s://localhost:%d/oauth2/authorization/spring-addons-public".formatted(isSsl ? "https" : "http", serverProperties.getPort()) )
				// I don't know quite why we are redirected to authorization-server port by default as we initially tried to access a client resource :/
			    .defaultSuccessUrl("%s://localhost:%d/ui/index.html".formatted(isSsl ? "https" : "http", serverProperties.getPort()), true)
				// This is how to map authorities from ID-token claims of our choice (instead of just `scp` claim)
				// Here we make use of the authorities mapper already defined by spring-addons for default filter-chain (the one for resource-server)
				// Refer to your authorization doc if it does not include roles to ID-tokens by default. For Keycloak, "realm roles" & "client roles" mappers must be added in clients -> {your client} -> Client scopes -> {your client}-dedicated -> Add mapper.
			    .userInfoEndpoint().userAuthoritiesMapper((authorities) -> authorities.stream()
	        		.filter(a -> OidcUserAuthority.class.isAssignableFrom(a.getClass()))
	        		.map(OidcUserAuthority.class::cast)
	        		.flatMap(oua -> authoritiesConverter.convert(oua.getIdToken().getClaims()).stream()).toList()
	        );
	
	    http.authorizeHttpRequests()
	            .requestMatchers("/login/**").permitAll()
	            .requestMatchers("/oauth2/**").permitAll()
	            .anyRequest().authenticated();
	    // @formatter:on

		// If SSL enabled, disable http (https only)
		if (isSsl) {
			http.requiresChannel().anyRequest().requiresSecure();
		}

		// compared to API filter-chain:
		// - sessions and CSRF protection are left enabled
		// - unauthorized requests to secured resources will be redirected to login (302
		// to login is Spring's default response when access is
		// denied)

		return http.build();
	}
}
```

## 5. Configuration Properties
In addition to resource-server properties, we have to provide client ones in `application.properties`:
```properties
server.port=8080

# shoud be set to where your authorization-server is
com.c4-soft.springaddons.security.issuers[0].location=https://localhost:8443/realms/master

# shoud be configured with a list of private-claims this authorization-server puts user roles into
# below is default Keycloak conf for a `spring-addons` client with client roles mapper enabled
com.c4-soft.springaddons.security.issuers[0].authorities.claims=realm_access.roles,resource_access.spring-addons-public.roles,resource_access.spring-addons-confidential.roles

com.c4-soft.springaddons.security.cors[0].path=/greet

com.c4-soft.springaddons.security.permit-all=/actuator/health/readiness,/actuator/health/liveness,/v3/api-docs/**,/api/public

spring.security.oauth2.client.provider.keycloak.issuer-uri=https://localhost:8443/realms/master

spring.security.oauth2.client.registration.spring-addons-public.provider=keycloak
spring.security.oauth2.client.registration.spring-addons-public.client-name=spring-addons-public
spring.security.oauth2.client.registration.spring-addons-public.client-id=spring-addons-public
spring.security.oauth2.client.registration.spring-addons-public.scope=openid,offline_access,profile
spring.security.oauth2.client.registration.spring-addons-public.authorization-grant-type=authorization_code

management.endpoint.health.probes.enabled=true
management.health.readinessstate.enabled=true
management.health.livenessstate.enabled=true
management.endpoints.web.exposure.include=*

spring.lifecycle.timeout-per-shutdown-phase=30s

logging.level.org.springframework.security.web.csrf=DEBUG
```

## 6. Controllers
We'll define two different kind of controllers:
- a `@RestController` for REST API endpoints (handle requests to `/api/**`)
- a `@Controller` for Thymeleaf pages (handle requests to `/ui/**`)

Note that spring-boot-actuator has its own `@RestControllers` and Swagger-UI has both `@RestControllers` and `@Controller` (serves JSON resources as well as HTML pages).

```java
@RestController
@RequestMapping("/api")
@PreAuthorize("isAuthenticated()")
public class ApiController {
	@GetMapping("/greet")
	public String getGreeting(JwtAuthenticationToken auth) {
		return "Hi %s! You are granted with: %s."
				.formatted(auth.getTokenAttributes().get(StandardClaimNames.PREFERRED_USERNAME), auth.getAuthorities()
						.stream().map(GrantedAuthority::getAuthority).collect(Collectors.joining(", ", "[", "]")));
	}
}
```
```java
@Controller
@RequestMapping("/ui")
@RequiredArgsConstructor
public class UiController {
	private final WebClient api;
	private final OAuth2AuthorizedClientService authorizedClientService;

	@GetMapping("/greet")
	public String getGreeting(Model model, Authentication auth) {
		try {
			final var authorizedClient = authorizedClientService.loadAuthorizedClient("spring-addons-public", auth.getName());
			final var response = api.get().uri("http://localhost:8080/api/greet")
					.attributes(ServerOAuth2AuthorizedClientExchangeFilterFunction
							.oauth2AuthorizedClient(authorizedClient))
					.exchangeToMono(r -> r.toEntity(String.class)).block();
			model.addAttribute("msg", response.getStatusCode().is2xxSuccessful() ? response.getBody() : response.getStatusCode().toString());
			
		} catch (RestClientException e) {
			final var error = e.getMessage();
			model.addAttribute("msg", error);
			
		}
		return "greet";
	}
}
```

## 7. UI Resources
`src/main/resources/static/ui/index.html`:
```html
<!DOCTYPE HTML>
<html>

<head>
	<meta charset="UTF-8" />
	<title>resource-server_with_ui</title>
</head>

<body>
	<p>
		<a href="/ui/greet">Go to Thymeleaf UI</a>
	</p>
	<p>
		<a href="/swagger-ui/index.html">Go to Swagger UI</a>
	</p>
</body>
```
`src/main/resources/templates/greet.html`:
```html
<!DOCTYPE HTML>
<html xmlns:th="http://www.thymeleaf.org">

<head>
	<meta charset="UTF-8" />
	<title>resource-server_with_ui</title>
</head>

<body>
	<h1>Spring-addons OAuth2 tutorial with resource-server and Thymeleaf client</h1>
	<h2 th:utext="${msg}">..!..</h2>
</body>
```

## 8. Conclusion
In this tutorial we saw how to configure different security filter-chains and select to which routes it should be applied.
In this case, we set-up a filter-chain with sessions and OAuth2 client configuration for UI and used a state-less OAuth2 resource-server filter-chain 
as fallback for all routes which are not intercepted by the first.